### `script`标签

+ `script`标签尽量放在`body`标签底部
+ `script`标签数量尽量少
+ `script`标签的`defer`通常用于不会修改dom的脚本,拥有该属性的`script`不在限制于`body`底部
+ 在使用`createElement("script")`时,加载成功后才会执行load事件(所以可以在load事件中执行脚本)
+ IE中`script`标签有一个`readyState`属性,可以用来判断脚本是否加载完成`(script.readyState == "loaded" || script.readyState == "complete")`

### 重排/重绘

+ 排版: 将页面元素看作一个有`宽高`,`填充(padding)`,`边框(border)`,`边距(margin)``[,位置,内容]`的盒子,在页面的显示的过程中,浏览器会根据这些盒子的大小,位置,内容,来计算出每个盒子的显示位置,然后将盒子显示在页面上
+ 重排: 当页面中的元素的几何属性,内容发生变化时,浏览器会重新计算元素的显示位置,这个过程称为重排
+ 绘制: 将元素的特殊附加属性,如背景色,阴影等,绘制到页面上,这个过程称为绘制
+ 重绘: 当页面中的元素的外观属性,如背景色,阴影等发生变化时,浏览器会重新绘制元素,这个过程称为重绘
+ 重排一定会引起重绘,重绘不一定会引起重排
+ 重排版有时只影响渲染树的一小部分，但也可以影响很大的一部分，甚至整个渲染树。浏览器需要重排版的部分越小，应用程序的响应速度就越快。

+ 触发重排的操作
  + 添加或删除可见的DOM元素
  + 元素位置改变
  + 元素尺寸改变(包括外边距,内边距,边框大小)
  + 内容改变(包括文本改变或图片大小改变等)
  + 页面渲染初始化
  + 浏览器窗口尺寸改变(resize事件)
  + 通过JavaScript获取某些属性值,如`offsetXXX`,`clientXXX`,`scrollXXX`,`getComputedStyle()`(布局信息由这些属性和方法返回最新的数据，所以浏览器不得不运行渲染队列中待改变的项目并重新排版以返回正确的值。)

+ 减少重排/重绘的情况
  + 避免使用table布局
  + 将动画效果应用到position属性为absolute或fixed的元素上
  + 避免设置多层内联样式
  + 将频繁重排的元素脱离文档流
  + 避免频繁操作样式,最好一次性重写style属性,或者将样式列表定义为class并一次性更改class属性
  + 避免频繁操作DOM,创建一个documentFragment,在它上面应用所有DOM操作,最后再把它添加到文档中
  + 对具有复杂动画的元素使用绝对定位,并将其脱离文档流
  + 避免使用CSS表达式
  + 避免频繁读取会引发回流的属性,如果确实需要多次使用,就用一个变量缓存起来

+ 解决办法:
  + 隐藏元素,然后对其进行操作,最后再显示出来
  + 使用文档片段(documentFragment),在文档片段中进行操作,最后再将文档片段添加到文档中
  + 将原始元素复制一份,然后对复制的元素进行操作,最后再将原始元素替换成复制的元素


### 事件
页面中存在大量元素，而且每个元素有一个或多个事件句柄与之挂接（例如onclick）时，可能会影响性能。连接每个句柄都是有代价的，无论其形式是加重了页面负担（更多的页面标记和JavaScript代码）还是表现在运行期的运行时间上。你需要访问和修改更多的DOM节点，程序就会更慢，特别是因为事件挂接过程都发生在onload（或DOMContentReady）事件中，对任何一个富交互网页来说那都是一个繁忙的时间段。挂接事件占用了处理时间，另外，浏览器需要保存每个句柄的记录，占用更多内存。当这些工作结束时，这些事件句柄中的相当一部分根本不需要（因为并不是100%的按钮或者链接都会被用户点到），所以很多工作都是不必要的。

#### 事件托管
事件逐层冒泡总能被父元素捕获。采用事件托管技术之后，你只需要在一个包装元素上挂接一个句柄，用于处理子元素发生的所有事件。

+ 最小化DOM访问，在JavaScript端做尽可能多的事情。
+ 在反复访问的地方使用局部变量存放DOM引用
+ 如果可能的话，使用速度更快的API，诸如querySelectorAll()和firstElementChild。
+ 批量修改风格，离线操作DOM树，缓存并减少对布局信息的访问。
+ 动画中使用绝对坐标，使用拖放代理。
+ 用事件托管技术最小化事件句柄数量。


# 循环
### for循环
它由四部分组成：初始化体，前测条件，后执行体，循环体。

当遇到一个for循环时，初始化体首先执行，然后进入前测条件。如果前测条件的计算结果为true，则执行循环体。然后运行后执行体。

### while循环
它由两部分组成：前测条件和循环体。

当遇到一个while循环时，进入前测条件。如果前测条件的计算结果为true，则执行循环体。

for循环和while循环间可以相互转换，但是for循环的效率更高。

### do-while循环
do-while循环是JavaScript中唯一一种后测试的循环，它包括两部分：循环体和后测试条件体

在一个do-while循环中，循环体至少运行一次，后测试条件决定循环体是否应再次执行。

### for-in循环
for-in循环用于枚举对象的属性。它包括两部分：属性名和要枚举的对象。

ps:自增体中存在一个隐式的赋值语句，它将属性名赋值给一个局部变量。这个局部变量在循环体中可用。
```javascript
let o = {x:1,y:2,z:3};
let keys=[],i=0;
for(keys[i++] in o);
console.log(keys); //["x","y","z"]
```

### for-of循环
for-of循环用于枚举可迭代对象的元素。它包括两部分：迭代变量和要枚举的对象。

ps:for-of循环是ES6中新增的，它的目的是取代for-in循环，因为for-in循环会枚举原型链上的属性，而for-of循环不会。
```javascript
let a = [1,2,3];
for(let v of a) console.log(v); //1 2 3
```

## 循环性能

在同样的循环迭代操作中，for-in循环比其他类型的循环慢7倍之多。因此推荐的做法如下：除非你需要对数目不详的对象属性进行操作，否则避免使用for-in循环。如果你迭代遍历一个有限的，已知的属性列表，使用其他循环类型更快

### 优化循环

选择正确的循环类型是优化循环的第一步。需要考虑的因素有：
+ 迭代的目的是什么？
+ 迭代的次数

优化循环工作量的第一步是减少对象成员和数组项查找的次数。(使用局部变量存储对象成员和数组项[包括length属性]的引用)

在JavaScript中，倒序循环可以略微提高循环性能

手动优化循环
```javascript
let i=100
while(i--){
    //do something
}

const len=1000;
let iterations =Math.floor(len/8),startAt = len%8,i=0;
while(i<iterations){
    switch(startAt){
        case 0:doSomething(i++);
        case 7:doSomething(i++);
        case 6:doSomething(i++);
        case 5:doSomething(i++);
        case 4:doSomething(i++);
        case 3:doSomething(i++);
        case 2:doSomething(i++);
        case 1:doSomething(i++);
    }
    startAt=0;
    iterations--
}
```

大多数情况下switch表达式比if-else更快，但只有当条件体数量很大时才明显更快。两者间的主要性能区别在于：当条件体增加时，if-else性能负担增加的程度比switch更多。

优化if-else的目标总是最小化找到正确分支之前所判断条件体的数量。最简单的优化方法是将最常见的条件体放在首位。

另外一种减少条件判断数量的方法是将if-else组织成一系列嵌套的if-else表达式。

查表法:有些情况下要避免使用if-else或switch。当有大量离散值需要测试时，if-else和switch都比使用查表法要慢得多。在JavaScript中查表法可使用数组或者普通对象实现，查表法访问数据比if-else或者switch更快，特别当条件体的数目很大时